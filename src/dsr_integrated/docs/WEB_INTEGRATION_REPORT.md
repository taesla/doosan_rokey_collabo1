# 🌐 ROS2-Web 통합 아키텍처 기술 보고서

## DSR Integrated 패키지의 웹 통합 설계 및 구현

---

## 1. 개요

본 보고서는 두산 로봇(M0609) 기반 물류 자동화 시스템에서 **ROS2와 웹 기술의 통합 방식**, **기술 선택의 근거**, 그리고 **아키텍처 설계 결정**에 대해 기술합니다.

---

## 2. 웹 통합의 두 가지 접근 방식

### 2.1 방식 A: 단순 모니터링 (Read-Only)

```
┌─────────────────────────────────────────────────────────┐
│                    ROS2 시스템                           │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐          │
│  │ 로봇노드  │───▶│ 토픽발행  │───▶│ 브릿지   │          │
│  └──────────┘    └──────────┘    └──────────┘          │
│                                        │                │
└────────────────────────────────────────│────────────────┘
                                         ▼
                              ┌─────────────────┐
                              │   웹 서버       │
                              │  (단방향 전송)   │
                              └────────┬────────┘
                                       ▼
                              ┌─────────────────┐
                              │   브라우저      │
                              │  (조회만 가능)   │
                              └─────────────────┘
```

**특징:**
- ROS2 → Web 단방향 데이터 흐름
- 조인트 각도, 센서 값 등 상태 정보만 표시
- 제어 명령 불가능
- 구현 단순, 보안 위험 낮음

**적용 사례:**
- 원격 상태 모니터링 대시보드
- 로그 뷰어
- 데이터 시각화 도구

---

### 2.2 방식 B: 통합 제어 (Bidirectional)

```
┌─────────────────────────────────────────────────────────────────┐
│                         ROS2 시스템                              │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │ DSR 로봇  │◀──▶│ 서비스   │◀──▶│ Sort노드 │◀──▶│ 상태관리 │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
│        ▲                               ▲              ▲         │
│        │                               │              │         │
│        └───────────────────────────────┼──────────────┘         │
│                                        │                        │
│                            ┌───────────┴───────────┐            │
│                            │   Server Node         │            │
│                            │  (Flask + SocketIO)   │            │
│                            └───────────┬───────────┘            │
│                                        │                        │
└────────────────────────────────────────│────────────────────────┘
                                         │
                           ┌─────────────┴─────────────┐
                           ▼                           ▼
                  ┌─────────────────┐       ┌─────────────────┐
                  │   로컬 브라우저  │       │  Firebase 연동  │
                  │  (실시간 제어)   │       │   (원격 접근)   │
                  └─────────────────┘       └─────────────────┘
```

**특징:**
- 양방향 실시간 통신
- 웹에서 로봇 직접 제어 가능
- 복잡한 상태 동기화 필요
- 보안 및 권한 관리 중요

**본 프로젝트 적용:**
- 분류 시작/정지/일시정지
- 그리퍼 개폐 제어
- 컨베이어 모드 전환
- 비상정지 및 복구
- 원테이크 시나리오 실행

---

## 3. 통합 제어 방식을 선택한 이유

### 3.1 운영 효율성

| 구분 | 단순 모니터링 | 통합 제어 |
|------|--------------|----------|
| 제어 방식 | 별도 터미널에서 ROS2 명령 | 웹 UI 버튼 클릭 |
| 상태 확인 | 터미널 로그 + 웹 대시보드 | 웹 UI 통합 |
| 오퍼레이터 요구 기술 | ROS2 CLI 숙련도 필요 | 웹 브라우저 사용 가능 |
| 반응 속도 | 터미널 전환 필요 (2-5초) | 즉시 (<100ms) |

**결론:** 비전문 오퍼레이터도 복잡한 물류 자동화 시스템을 직관적으로 운영할 수 있어야 했습니다.

### 3.2 실시간성 요구사항

물류 자동화 시스템에서는 다음과 같은 즉각적 대응이 필요합니다:

- **충돌 감지 시**: 즉시 비상정지 → 복구 시퀀스 시작 → 진행률 표시
- **물체 감지 시**: 컨베이어 정지 → Pick 동작 → 분류 → 적재
- **오류 발생 시**: 알림 표시 → 수동 개입 옵션 제공

단방향 모니터링으로는 이러한 **이벤트-액션 루프**를 구현할 수 없습니다.

### 3.3 데이터 일관성

```python
# 통합 제어의 단일 진실 소스(Single Source of Truth)
class RobotStateManager:
    """ROS2 노드와 웹 UI가 동일한 상태 객체를 참조"""
    
    def complete_cycle(self, box_class: str):
        # 1. 내부 상태 업데이트
        self.state.total_sorted += 1
        
        # 2. ROS2 토픽 발행 (다른 노드용)
        self._publish_status()
        
        # 3. 웹 UI 실시간 업데이트 (SocketIO)
        socketio.emit('sort_status', self.get_status())
        
        # 4. Firebase 영구 저장 (선택적)
        self.firebase.update_logistics_count(box_class)
```

---

## 4. 기술 스택 선택 근거

### 4.1 Flask vs 대안 비교

| 프레임워크 | 장점 | 단점 | 본 프로젝트 적합성 |
|-----------|------|------|-------------------|
| **Flask** | 경량, 유연, Python 네이티브 | 대규모 앱에 부적합 | ⭐⭐⭐⭐⭐ |
| Django | 풍부한 기능, ORM | 무거움, 과도한 기능 | ⭐⭐ |
| FastAPI | 비동기, 자동 문서화 | SocketIO 통합 복잡 | ⭐⭐⭐ |
| Node.js (Express) | 실시간에 강함 | Python 생태계 단절 | ⭐⭐ |

**Flask 선택 이유:**

1. **ROS2와의 자연스러운 통합**
   ```python
   # Flask 앱이 ROS2 노드 내부에서 직접 실행
   class ServerNode(Node):
       def __init__(self):
           super().__init__('web_server_node')
           self.app = Flask(__name__)
           self.socketio = SocketIO(self.app)
           
           # ROS2 서비스 클라이언트를 Flask 라우트에서 직접 호출
           self.cli_start_sort = self.create_client(Trigger, '/dlar/sort/start')
   ```

2. **단일 프로세스 아키텍처**
   - 별도의 브릿지 프로세스 불필요
   - 상태 공유가 직접적 (메모리 참조)
   - 지연 시간 최소화

3. **SocketIO 완벽 지원**
   ```python
   # Flask-SocketIO: 설치 한 줄로 실시간 통신 구현
   socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')
   ```

### 4.2 Firebase vs 대안 비교

| 솔루션 | 실시간 DB | 인증 | 호스팅 | 비용 | 설정 복잡도 |
|--------|----------|------|--------|------|------------|
| **Firebase** | ✅ Realtime DB | ✅ Auth | ✅ Hosting | 무료 티어 | 낮음 |
| AWS IoT | ✅ | ✅ | ❌ (별도) | 종량제 | 높음 |
| MQTT + Broker | ✅ | ❌ (직접) | ❌ | 서버 비용 | 중간 |
| PostgreSQL + WebSocket | ❌ (폴링) | ❌ (직접) | ❌ | 서버 비용 | 높음 |

**Firebase 선택 이유:**

1. **외부 접근 문제 해결**
   ```
   문제: 로컬 네트워크 외부에서 로봇 상태 확인 불가
   
   해결: Firebase Realtime Database
   ┌──────────┐     ┌──────────────┐     ┌──────────────┐
   │ 로컬 ROS2│────▶│ Firebase DB  │◀────│ 외부 브라우저│
   │ 시스템   │     │ (클라우드)   │     │ (어디서든)  │
   └──────────┘     └──────────────┘     └──────────────┘
   ```

2. **실시간 동기화 내장**
   ```javascript
   // 프론트엔드: 자동으로 실시간 업데이트 수신
   firebase.database().ref('logistics').on('value', (snapshot) => {
       updateDashboard(snapshot.val());
   });
   ```

3. **인증 및 권한 관리**
   ```json
   // Firebase Security Rules
   {
     "rules": {
       "logistics": {
         ".read": "auth != null",
         ".write": "auth != null && auth.token.admin === true"
       }
     }
   }
   ```

### 4.3 SocketIO vs 대안 비교

| 기술 | 양방향 | 재연결 | 브라우저 호환 | 구현 복잡도 |
|------|--------|--------|--------------|------------|
| **SocketIO** | ✅ | ✅ 자동 | ✅ 모든 브라우저 | 낮음 |
| WebSocket 직접 | ✅ | ❌ 직접 구현 | ⚠️ 일부 | 높음 |
| Server-Sent Events | ❌ 단방향 | ⚠️ 제한적 | ✅ | 중간 |
| HTTP Polling | ⚠️ 의사 | N/A | ✅ | 낮음 |

**SocketIO 선택 이유:**

```python
# 서버: 이벤트 기반 통신
@socketio.on('sort_start')
def handle_sort_start():
    success, msg = ros_node.call_start_sort()
    socketio.emit('sort_result', {'success': success, 'message': msg})

@socketio.on('emergency_stop')
def handle_emergency():
    ros_node.call_emergency_stop()
    socketio.emit('robot_state', {'state': 'EMERGENCY_STOP'})
```

```javascript
// 클라이언트: 직관적인 이벤트 핸들링
socket.emit('sort_start');
socket.on('sort_result', (data) => {
    showNotification(data.success ? '시작됨' : '실패: ' + data.message);
});
```

---

## 5. 충돌 감지를 로컬 노드로 분리한 이유

### 5.1 초기 설계: 웹 통합 시도

```
초기 구상:
┌─────────────────────────────────────────┐
│              웹 서버 노드               │
│  ┌─────────────────────────────────┐   │
│  │  Flask + SocketIO               │   │
│  │  + 상태 모니터링                 │   │
│  │  + 충돌 감지 ← 문제 발생!       │   │
│  │  + 복구 시퀀스                   │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### 5.2 웹 통합의 문제점

#### 문제 1: 네트워크 지연 (Critical)

```
충돌 감지 시간 요구사항: < 10ms (안전 기준)

웹 통합 시 지연:
[DSR 드라이버] ─(ROS2 토픽)─▶ [웹 서버] ─(SocketIO)─▶ [브라우저]
                  ~2ms              ~5ms              ~10-50ms
                                    
                           ─(SocketIO)─▶ [웹 서버] ─(ROS2 서비스)─▶ [DSR]
                              ~10-50ms        ~5ms           ~5ms
                              
총 지연: 37-122ms → 안전 기준 초과!
```

#### 문제 2: 웹 연결 의존성 (Critical)

```python
# 웹 통합 방식의 위험성
def on_collision_detected():
    # 만약 웹 연결이 끊어져 있다면?
    socketio.emit('collision', {...})  # 전송 실패
    # → 복구 시퀀스 시작 불가!
    # → 로봇 손상 위험!
```

#### 문제 3: 스레드 경합

```python
# Flask의 threading 모드에서 문제 발생
# HTTP 요청 처리 중 충돌 이벤트 발생 시
# GIL(Global Interpreter Lock)로 인한 지연 가능성
```

### 5.3 최종 설계: 로컬 노드 분리

```
최종 아키텍처:
┌─────────────────────────────────────────────────────────────────┐
│                        ROS2 시스템 (로컬)                        │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Sort Node (메인)                       │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │   │
│  │  │ StateMonitor │  │ Recovery     │  │ PickPlace    │   │   │
│  │  │ (충돌 감지)  │  │ (자동 복구)  │  │ (작업 로직)  │   │   │
│  │  └──────┬───────┘  └──────▲───────┘  └──────────────┘   │   │
│  │         │                 │                              │   │
│  │         └────(콜백)───────┘                              │   │
│  └──────────────────────────────────────────────────────────┘   │
│         │                                                        │
│         │ (ROS2 토픽: /dlar/recovery_status)                    │
│         ▼                                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                 Web Server Node                           │   │
│  │           (상태 표시 및 수동 제어만)                       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 분리 설계의 장점

| 항목 | 웹 통합 | 로컬 노드 분리 |
|------|--------|---------------|
| 충돌 감지 지연 | 37-122ms | **< 5ms** |
| 네트워크 의존성 | 있음 (위험) | **없음** |
| 복구 신뢰성 | 웹 연결 필수 | **독립 실행** |
| 실시간성 | 네트워크 품질 의존 | **보장됨** |

### 5.5 구현 코드 비교

```python
# ❌ 웹 통합 방식 (문제 있음)
class WebServerNode(Node):
    def _collision_callback(self, msg):
        # 웹으로 알림 → 웹에서 복구 명령 대기
        socketio.emit('collision_detected', {...})
        # 브라우저가 응답할 때까지 대기... (위험!)

# ✅ 로컬 노드 방식 (안전)
class SortNode(Node):
    def __init__(self):
        # 충돌 감지 모듈 (로컬)
        self.state_monitor = RobotStateMonitor(self)
        self.state_monitor.set_collision_callback(self._on_collision)
        
        # 자동 복구 모듈 (로컬)
        self.recovery = CollisionRecovery(self, self.robot, self.state)
    
    def _on_collision(self):
        """충돌 즉시 처리 - 웹 연결과 무관하게 동작"""
        self.state.emergency_stop()  # 즉시 정지
        
        # 자동 복구 시작 (로컬에서 독립 실행)
        threading.Thread(target=self.recovery.auto_recover).start()
        
        # 웹에는 알림만 (optional, 실패해도 복구는 진행)
        self._publish_recovery_status('detected', '충돌 감지됨', 0)
```

---

## 6. 전체 아키텍처 요약

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              DSR Integrated 패키지                           │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         Safety Layer (로컬)                          │    │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │    │
│  │  │ RobotStateMonitor│  │ CollisionRecovery│  │ RobotStateManager│     │    │
│  │  │ • 하트비트 감시  │  │ • 서보 OFF/ON   │  │ • 비상정지 관리 │     │    │
│  │  │ • 충돌 감지     │  │ • 안전 이동     │  │ • 상태 영속화   │     │    │
│  │  │ • 드라이버 복구 │  │ • 블록 반납     │  │ • 복구 대기     │     │    │
│  │  └────────┬────────┘  └────────▲────────┘  └────────▲────────┘     │    │
│  │           │                    │                    │              │    │
│  │           └────────(콜백)──────┴────────────────────┘              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                         (ROS2 토픽/서비스)                                   │
│                                    │                                         │
│  ┌─────────────────────────────────▼───────────────────────────────────┐    │
│  │                          Task Layer                                  │    │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │    │
│  │  │   PickPlaceTask │  │ ConveyorHandler │  │   RobotController│     │    │
│  │  │ • Pick 시퀀스   │  │ • 센서 연동     │  │ • DSR API 래핑  │     │    │
│  │  │ • Place 시퀀스  │  │ • 자동 모드     │  │ • 모션 제어     │     │    │
│  │  │ • DI 분류       │  │ • 감지 콜백     │  │ • 그리퍼 제어   │     │    │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                         (ROS2 토픽/서비스)                                   │
│                                    │                                         │
│  ┌─────────────────────────────────▼───────────────────────────────────┐    │
│  │                           Web Layer                                  │    │
│  │  ┌─────────────────────────────────────────────────────────────┐   │    │
│  │  │                      ServerNode                              │   │    │
│  │  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │   │    │
│  │  │  │   Flask     │  │  SocketIO   │  │  Firebase   │         │   │    │
│  │  │  │ • REST API  │  │ • 실시간    │  │ • 클라우드  │         │   │    │
│  │  │  │ • HTML 렌더 │  │ • 이벤트    │  │ • 외부 접근 │         │   │    │
│  │  │  └─────────────┘  └─────────────┘  └─────────────┘         │   │    │
│  │  └─────────────────────────────────────────────────────────────┘   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
└────────────────────────────────────│─────────────────────────────────────────┘
                                     │
                    ┌────────────────┴────────────────┐
                    ▼                                 ▼
           ┌─────────────────┐              ┌─────────────────┐
           │   로컬 브라우저  │              │   원격 대시보드  │
           │   (제어 + 모니터)│              │   (모니터링)    │
           └─────────────────┘              └─────────────────┘
```

---

## 7. 결론

### 7.1 핵심 설계 원칙

1. **안전 최우선**: 충돌 감지/복구는 네트워크 독립적으로 로컬에서 처리
2. **운영 편의성**: 웹 UI를 통한 직관적 제어로 비전문 오퍼레이터 지원
3. **확장성**: Firebase 연동으로 원격 모니터링 및 데이터 영속화 지원
4. **실시간성**: SocketIO 기반 양방향 통신으로 즉각적 피드백 제공

### 7.2 기술 선택 요약

| 영역 | 선택 기술 | 핵심 이유 |
|------|----------|----------|
| 웹 프레임워크 | Flask | ROS2 노드 내 직접 통합, Python 생태계 |
| 실시간 통신 | SocketIO | 양방향, 자동 재연결, 브라우저 호환성 |
| 클라우드 DB | Firebase | 외부 접근, 실시간 동기화, 무료 티어 |
| 안전 시스템 | 로컬 노드 | 네트워크 무관, 지연 최소화, 신뢰성 |

### 7.3 이 아키텍처의 가치

본 설계는 **"웹의 편의성"**과 **"로봇 제어의 안전성"**이라는 상충되는 요구사항을 계층 분리를 통해 해결했습니다:

- **웹 레이어**: 사용자 경험, 원격 접근, 데이터 시각화에 집중
- **로컬 레이어**: 실시간성, 안전성, 신뢰성에 집중

이를 통해 산업용 로봇 시스템에서 요구하는 안전 기준을 충족하면서도, 현대적인 웹 기술의 장점을 최대한 활용할 수 있었습니다.

---

*작성일: 2025년 12월 5일*  
*프로젝트: DSR Integrated - 두산 로봇 물류 자동화 시스템*
